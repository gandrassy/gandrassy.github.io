Unit test:
---------
Egy funkcióra (tipikusan egy metódusra) vonatkozik.

Integration test
----------------
A szoftver különböző részeinek interakcióját teszteli. 
Például egy rest endpointra beküldött adat az elvárt választ váltja-e ki?
Akár több különböző klassz számos metódusa is lehet mögötte, nem számít, itt csak a végeredmény fontos.

Funkcionális test
-----------------
Komplex program rendeltetésszerű használata. Lehet automatizált (Selenium) vagy user teszt. aka beta test

Stress test
-----------
terheléses teszt: ki tud-e szolgálni elegendő usert

Penetration test
----------------
etikus hackerek megpróbálják megtörni


Junit
=====

1. A root-ba csinált egy új directoryt test névvel aztán a file/project/structure-ban beállítja, hogy ez a directory test típusú.
2. jobb gombbal rákattint a class-ra, generate test, Junit4, bechekkolja a tesztelendő metódusokat, és OK

A test unitok sima függvények. beleírjuk, hogy:
  assertEquals(várt eredmény, tesztelendő fv)  pl. 

    @Test
    public void grow() {
      assertEquals( Integer.valueOf(1), appleTree.getheight() );
      appleTree.grow();
      assertEquals( Integer.valueOf(2), appleTree.getheight() );
    }



További ellenőrzések:

fail(message)
A hívó teszt sikertelen futását eredményezi

assertTrue([message,] boolean condition) or assertFalse
Ellenörzi, hogy a megadott feltétel igaz (hamis) – e.

assertNull([message,] obj) or NotNull
Egy Objektum null (nem null).

assertEquals([message,] expected, actual)
Ellenőrzi, hogy két objektum egyenlő-e az expected.equals() paraméter szerint.

assertSame([message,] expected, actual) or assertNotSame
Referencia típusú objektumoknál használatos, azt ellenőrzi, hogy két változó pontosan ugyanarra a memóriacímre mutat-e? 


Megadható egy 

   @Before (Junit5-ben @BeforeEach)
   public void before() {
   }

is. Ez minden egyes tesz előtt lefut, ide ki lehet írni a közös kódot, pl. appleTree = new Appletree();

Párja az

  @After (Junit5-ben @AfterEach)
   public void after() {
   }

Ide kerülhet pl. a sout( appletree.toString() );

van ilyen is:

  @BeforeClass (Junit5-ben @BeforeAll)
   public void beforeClass() {
   }

Ez nem minden egyes teszt előtt fut le, hanem az egész tesztsorozat előtt egyszer.

párja az

  @AfterClass
   public void afterClass() {
   }

általában valami


További annotációk:

@Test public void method()
Teszt metódus jelölése

@Test (expected = Exception.class) 
A teszt sikertelen a megadott típusú kivétel hiányában

@Test(timeout=100) 
A teszt sikertelen, ha a metódus mem fejeződik be adott idő alatt

@Ignore or @Ignore("Why disabled") (Junit5-ben @Disabled)
Adott teszt metódus kihagyása


Exception testing
=================

Csak egyetlen egy féle exceptionra tudunk tesztelni. Pl...


public class MyClass {
  public int multiply(int x, int y) {
  if (x > 999) { throw new IllegalArgumentException("x>999"); }
  return x / y;
  }
} 

public class MyClassTest {
  @Test(expected = IllegalArgumentException.class)
  public void testExceptionIsThrown() {
    MyClass tester = new MyClass();
    tester.multiply(1000, 5);
  }

  @Test
  public void testMultiply() {
    MyClass tester = new MyClass();
    assertEquals(50, tester.multiply(10, 5));
  }
} 



Statikus void metódus mockolása: (Junit5)
=========================================

@Test
public void emailtest() {

    try (MockedStatic<Transport> transport = mockStatic(Transport.class) ) {
    
        transport.when( () -> Transport.send(any()) ).thenAnswer( Answer<Void> invocation -> {
            java.mail.Message message = invocation.getArgument(0);
            assertEquals("test@mail.ru", message.getRecipients(RecipientType.TO)[0].toString());
            return null;
        });
      
        assertDoesNotThrow( () -> emailService.sendAutomatedEmail(scheduledEmail) );
    
    }

}


Konstruktőr mockolása: (Junit5)
===============================

Hasonlóan kell mockolni azt, ha a tesztelendő metódusban egy osztályt példányosítanak.

Tegyük fel, hogy a tesztelendő metódusunk a dbService-ben van, és így néz ki:

public ObjectId saveNewEntity(String name, int phoneNo) throws dataBaseAccessException {
    PhonebookEntity phonebookEntity = new PhonebookEntity(name, phoneNo);
    phonebookEntity.setStatus(Status.CREATED);
    phonebookEntity = phonebookRepository.save(phonebookEntity);
    return phonebookEntity.getId();
}


erre a tesztet így írjuk:


@Test
void testSaveEntity() {
    DbService dbService = new DbService();
    DbRepository mockRepo = mock(DbRepository.class);
    when(mockRepo.save(any(PhonebookEntity.class))).thenAnswer(invocation -> {
        PhonebookEntity pbe = (PhonebookEntity) invocation.getArgument(0);
        pbe.setId(new ObjectId(1234567890abcdef12345678));
        return pbe;
    });
    ReflectionTestUtils.setField(dbService, "phonebookRepository", mockRepo);
    try (MockedConstruction<PhonebookEntity> mocked = mockConstruction(PhonebookEntity.class, (mock, context) -> {
                                List<?> constructorArgs = context.arguments();
                                assertEquals("Mr. John Doe", constructorArgs.get(0));
                                assertEquals(3616302130, constructorArgs.get(1)); 
                            })) {
        ObjectId oid = assertDoesNotThrow(() -> dbService.saveNewEntity("Mr. John Doe", 3616302130));
        assertEquals(new ObjectId(1234567890abcdef12345678), oid);
        List<PhonebookEntity> constructed = mocked.constructed();
        assertEquals(1, constructed.size());
        verify(constructed.get(0), times(1)).setStatus(Status.CREATED);
        verify(mockRepo, times(1)).save(constructed.get(0));
    }
}
                    

